---
title: "[통신 및 네트워크] 라우팅 알고리즘"
date: 2023-11-24 13:11:59 +0900
categories: [Study, Data Communication Network]
tags: [network]
---

> 데이터통신과 네트워킹, 조성호 저, 인피니티북스
> 
> > Chapter 10. 라우팅 알고리즘

<br>

## **정적 라우팅 알고리즘**

### **라우팅 알고리즘 개요**

네트워크 계층에 있는 IP의 가장 중요한 작업은 출발지에서 목적지까지 패킷을 전달하는 라우팅이다. 그리고 패킷을 목적지까지 보내는 방법을 결정하는 라우팅 알고리즘이 필요하다. 라우팅 알고리즘은 크게 정적/동적으로 나뉜다.

- **정적 라우팅 알고리즘**: 현재의 상태에서 어떤 곳으로 패킷을 보내야 목적지에 도달하는지를 찾는 알고리즘
  
  - 많은 라우터들로 연결된 인터넷의 상태는 수시로 변하는데, 새 라우터가 생겨나기도 하고 고장나거나 잘 다니던 경로가 혼잡해져 패킷이 갑자기 느리게 전달되기도 함. 정적 라우팅 알고리즘은 이러한 변화하는 상태를 반영하지 못함.
  
  - 최단경로 알고리즘, 플러딩 알고리즘
  
  - e.g.) 내비게이션 길 찾기 등

- **동적 라우팅 알고리즘**: 라우터의 상태를 감지하여 경로를 변경하는 알고리즘
  
  - 주기적으로 교통 상황을 점검하여 보다 빠른 길로 안내함
  
  - 거리벡터 라우팅 알고리즘, 연결상태 라우팅 알고리즘, 계층적 라우팅 알고리즘
  
  - e.g.) 티맵, 카카오내비 등

일반적으로 동적 라우팅 알고리즘은 정적 라우팅 알고리즘을 바탕으로 만들어진다.

<br>

---

##### 📌알아야 할 그래프 표현들

(image)

인터넷에서 라우터들과 통신선의 연결을 그림으로 그리면 왼쪽 그림과 같이 그래프로 표현할 수 있다. 이때 그래프란 노드와 선의 집합이며, 노드는 라우터, 선은 통신선을 의미한다. 선 위에 적혀있는 숫자들은 패킷을 전송하는데 걸린 시간 또는 거리이며, 밀리초(msec) 단위이다. 라우팅 알고리즘이 여러 개의 선 중 하나를 선택할 때는 가장 작은 숫자를 가진 선을 선택하여(최단 경로 선택), 같은 속도의 길이 있다면 그 중 하나만 선택한다. 같은 속도를 가진 여러 개의 길이 있더라도 패킷을 전달하는 길은 오직 하나의 경로만 필요하기 때문이다.  
라우팅 알고리즘이 작동하여 최소시간 경로(=최단경로)가 결정되면, 결과는 오른쪽 그림과 같이 트리 구조가 된다. 이때 트리는 사이클이 존재하지 않는다. 사이클이 존재하는 그래프의 경우, 패킷이 목적지에 전달되지 못하고 사이클을 계속 도는 문제가 발생하기 때문에 반드시 사이클이 없는 트리의 형태를 유지한다.

---

<br>

### **최단경로(shortest path)/다익스트라 알고리즘**

<u>집합의 개념을 사용하는 정적 라우팅 알고리즘</u>

1. 출발 지점의 라우터(노드)를 집합에 넣음

2. 새로운 라우터가 집합에 들어오면, 집합에 속한 라우터들에서 보이는 경로 중 가장 짧은 경로(혹은 가장 빠른 시간)을 찾아 집합에 넣음

3. 모든 라우터가 집합에 다 들어갈 때까지 앞의 과정을 반복함

(image)

도로를 그래프로 표시하여 각 지점까지의 최단경로를 찾는 데에 많이 사용됨.

<br>

### **플러딩(flooding) 알고리즘**

<u>네트워크에 홍수를 일으켜 가장 빠른 길을 찾는 정적 라우팅 방식</u>

플러딩에 참가한 라우터들은 패킷이 들어온 선을 제외한 모든 선에 패킷을 복사하여 보낸다. 이때 패킷에는 지나온 라우터들을 적어 놓는다. 패킷이 라우터를 지날 때마다 복사가 되기 때문에 모든 선이 패킷들로 홍수를 이루게 된다. 가장 먼저 도착한 패킷에 적혀 있는 경로가 가장 빠른 경로가 된다.

방법이 단순하여 구현하기 쉽지만, 많은 패킷이 폭주하여 네트워크의 정체를 유발하는 단점이 있어 소규모 네트워크에서 주로 사용된다.

<br>

<br>

## **동적 라우팅 알고리즘**

### **거리벡터 라우팅(distance vector routing) 알고리즘**

<u>아파넷 개발 초기에 많이 사용되던 동적 알고리즘</u>

각 라우터들은 주기적으로 라우팅 테이블을 주고받는데, 이 라우팅 테이블에는 자기 자신에서 다른 라우터까지 가는데 걸리는 시간(거리)이 명시되어 있다. 다른 라우터까지의 거리에 대한 연속적인 값(벡터)을 나타내기 때문에 거리벡터 라우팅이라 부른다. 주변 라우터들로부터 라우팅 테이블을 받아 자신만의 라우팅 테이블을 만들고, 이를 다시 주변 라우터에게 전송하는 방식이다.

(left image) (right image)

D 라우터의 경우 B, C, E가 인접한 라우터이기 때문에 세 라우터와 주기적으로 테이블(벡터)을 주고받는다. 한 예로 B 테이블은 B 라우터가 생각하는 다른 라우터까지의 시간이다. 중요한 것은 오른쪽 그림의 각 테이블 밑에 있는 'D까지 걸린 시간'인데, 이는 왼쪽 그래프의 선 위에 적혀 있는 숫자들(밀리초)과 일치한다. +1은 B 라우터가 D에게 테이블을 보내어 도착할 때까지 1msec가 걸렸다는 의미이다. D가 B, C, E 라우터들로부터 라우팅 테이블을 받아 D 테이블을 생성할 때는, 각 라우터 본래의 테이블에 D까지 걸린 시간을 더해 가장 짧은 시간을 선택한다. 이때 D 라우터가 D 자신에게 보내는 시간은 당연히 0이 된다.

<br>

### **연결상태 라우팅(link state routing) 알고리즘**

자신에게 연결된 라우터 정보만을 보내고, 최단경로 알고리즘을 사용한다. 일련번호와 나이를 추가하여 잘못된 정보가 도착하는 것을 막고, 특정 라우터가 고장나는 것을 확인할 수 있게 해 준다.

1. **인접한 라우터(이웃 라우터)들 파악**: 라우터가 처음 시작되면 자신의 주변에 HELLO 패킷을 보냄. HELLO 패킷을 받은 라우터는 ACK 패킷을 보냄으로써 서로 연결됨을 확인하고, HELLO 패킷이 전송된 시간을 계산함.

2. **라우팅 테이블을 주기적으로 모든 라우터에게 전송(플러딩)**: 이웃 라우터들이 파악된 후 라우터들은 주기적으로 테이블을 주고받음. 테이블에는 라우터 이름, 일련번호, 나이, 자신에게 연결된 이웃 라우터의 거리 정보가 기재되어 있음. 이렇게 만들어진 테이블은 플러딩 방식으로 모든 라우터들에게 전달됨.

3. **최단경로 알고리즘을 사용하여 라우팅 테이블 생성**:  모든 라우터들로부터 정보가 모이면, 각 라우터들은 최단경로 알고리즘을 사용하여 모든 노드까지 가는데 걸리는 최소시간을 계산하여 라우팅 테이블을 만듦.

4. **라우터 구조와 라우팅 테이블 값을 지속적으로 업데이트**

<br>

### **계층적 라우팅**

<u>라우터를 계층 형태로 만드는 방식</u>

일정한 지역을 하나씩 묶어서 대표 라우터를 선정하고, 지역끼리 패킷을 주고받을 때 대표 라우터끼리 통신한다. 지역 안에서는 각자 알아서 라우팅 한다.

- **내부 라우터**: 지역 안에 속한 라우터
  
  - 시작점에서 목적지까지 가장 빠르게 패킷을 전송할 수 있도록 라우팅 테이블을 유지하는데, 이는 곧 패킷 전송의 효율성을 중시함을 의미함.
  
  - 연결상태 라우팅 알고리즘 사용

- **외부 라우터**: 지역끼리 통신하는 라우터
  
  - 도달 가능성을 확인하는 것이 중요
  
  - 거리벡터 라우팅 알고리즘 사용

<br>

### **거리벡터와 연결상태 라우팅 알고리즘 비교**

(image)

<br>
